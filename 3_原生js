1 基本数据类型
  数字 Number 
    八进制数和十六进制数
    浮点数
      要定义浮点值，必须包括小数点和小数点后的一位数字（例如，用 1.0 而不是 1）。这被看作浮点数字面量。
    特殊的 Number 
       几个特殊值也被定义为 Number 类型。前两个是 Number.MAX_VALUE 和 Number.MIN_VALUE，它们定义了 Number 值集合的外边界。所有 ECMAScript
       数都必须在这两个值之间。不过计算生成的数值结果可以不落在这两个值之间。
      当计算生成的数大于 Number.MAX_VALUE 时，它将被赋予值 Number.POSITIVE_INFINITY，意味着不再有数字值。同样，生成的数值小于 
      Number.MIN_VALUE 的计算也会被赋予值 Number.NEGATIVE_INFINITY，也意味着不再有数字值。如果计算返回的是无穷大值，那么生成的结果不能再用
      于其他计算。
      事实上，有专门的值表示无穷大，（如你猜到的）即 Infinity。Number.POSITIVE_INFINITY 的值为 Infinity。Number.NEGATIVE_INFINITY 的值为
      -Infinity。
     由于无穷大数可以是正数也可以是负数，所以可用一个方法判断一个数是否是有穷的（而不是单独测试每个无穷数）。可以对任何数调用 isFinite() 方法
     ，以确保该数不是无穷大。
     特殊值  NAN
     
  布尔值 booleans  值为true 或false
    Boolean 类型是 ECMAScript 中最常用的类型之一。它有两个值 true 和 false （即两个 Boolean 字面量）。
    即使 false 不等于 0，0 也可以在必要时被转换成 false，这样在 Boolean 语句中使用两者都是安全的
    
  空 null  object - 如果变量是一种引用类型或 Null 类型的
    typeof 运算符对于 null 值会返回 "Object"。这实际上是 JavaScript 最初实现中的一个错误，然后被 ECMAScript 沿用了。现在，null 被认为是对象的
    占位符，从而解释了这一矛盾，但从技术上来说，它仍然是原始值。
    alert(null == undefined);  //输出 "true"
    
  未定义 undefined
    当声明的变量未初始化时，该变量的默认值是 undefined
    var oTemp;
    前面一行代码声明变量 oTemp，没有初始值。该变量将被赋予值 undefined，即 undefined 类型的字面量。可以用下面的代码段测试该变量的值是否等于
    undefined：
    var oTemp;  alert(oTemp == undefined);
    这段代码将显示 "true"，说明这两个值确实相等。还可以用 typeof 运算符显示该变量的值是 undefined：
    var oTemp;  alert(typeof oTemp); //输出 "undefined"
    提示：值 undefined 并不同于未定义的值。但是，typeof 运算符并不真正区分这两种值。考虑下面的代码：
    var oTemp;

    alert(typeof oTemp);  //输出 "undefined"
    alert(typeof oTemp2);  //输出 "undefined"
    前面的代码对两个变量输出的都是 "undefined"，即使只有变量 oTemp2 从未被声明过。如果对 oTemp2 使用除 typeof 之外的其他运算符的话，会引起
    错误，因为其他运算符只能用于已声明的变量上。
    例如，下面的代码将引发错误：
    var oTemp;  alert(oTemp2 == undefined);
    当函数无明确返回值时，返回的也是值 "undefined"，如下所示：
    function testFunc() {
    }

    alert(testFunc() == undefined); //输出 "true"
    
  字符串 string
    String 类型的独特之处在于，它是唯一没有固定大小的原始类型。可以用字符串存储 0 或更多的 Unicode 字符，有 16 位整数表示（Unicode 是一种
    国际字符集，本教程后面将讨论它）。
    字符串中每个字符都有特定的位置，首字符从位置 0 开始，第二个字符在位置 1，依此类推。这意味着字符串中的最后一个字符的位置一定是字符串的长度减 1：
    字符串字面量是由双引号（"）或单引号（'）声明的。而 Java 则是用双引号声明字符串，用单引号声明字符。但是由于 ECMAScript 没有字符类型，所以
    可使用这两种表示法中的任何一种
    
  判断数据类型  typeof 其中 判断未定义的数据类型不安全
  
\n
换行
\t
制表符
\b
空格
\r
回车
\f
换页符
\\
反斜杠
\'
单引号
\"
双引号
\0nnn
八进制代码 nnn 表示的字符（n 是 0 到 7 中的一个八进制数字）
\xnn
十六进制代码 nn 表示的字符（n 是 0 到 F 中的一个十六进制数字）
\unnnn
十六进制代码 nnnn 表示的 Unicode 字符（n 是 0 到 F 中的一个十六进制数字）


2 数据类型
   字符串  数组  object  json

3 字符串
    创建 String 对象的语法：
    new String(s);
    String(s);
    参数
    参数 s 是要存储在 String 对象中或转换成原始字符串的值。
    返回值
    当 String() 和运算符 new 一起作为构造函数使用时，它返回一个新创建的 String 对象，存放的是字符串 s 或 s 的字符串表示。
    当不用 new 运算符调用 String() 时，它只把 s 转换成原始的字符串，并返回转换后的值。
    String 对象属性
    属性	描述
    constructor	对创建该对象的函数的引用
    length	字符串的长度
    prototype	允许您向对象添加属性和方法
anchor()	创建 HTML 锚。
big()	用大号字体显示字符串。
blink()	显示闪动字符串。
bold()	使用粗体显示字符串。
charAt()	返回在指定位置的字符。
charCodeAt()	返回在指定的位置的字符的 Unicode 编码。
concat()	连接字符串。
fixed()	以打字机文本显示字符串。
fontcolor()	使用指定的颜色来显示字符串。
fontsize()	使用指定的尺寸来显示字符串。
fromCharCode()	从字符编码创建一个字符串。
indexOf()	检索字符串。
italics()	使用斜体显示字符串。
lastIndexOf()	从后向前搜索字符串。
link()	将字符串显示为链接。
localeCompare()	用本地特定的顺序来比较两个字符串。
match()	找到一个或多个正则表达式的匹配。
replace()	替换与正则表达式匹配的子串。
search()	检索与正则表达式相匹配的值。
slice()	提取字符串的片断，并在新的字符串中返回被提取的部分。
small()	使用小字号来显示字符串。
split()	把字符串分割为字符串数组。
strike()	使用删除线来显示字符串。
sub()	把字符串显示为下标。
substr()	从起始索引号提取字符串中指定数目的字符。
substring()	提取字符串中两个指定的索引号之间的字符。
sup()	把字符串显示为上标。
toLocaleLowerCase()	把字符串转换为小写。
toLocaleUpperCase()	把字符串转换为大写。
toLowerCase()	把字符串转换为小写。
toUpperCase()	把字符串转换为大写。
toSource()	代表对象的源代码。
toString()	返回字符串。
valueOf()	返回某个字符串对象的原始值



4 数组
创建 Array 对象的语法：
new Array();
new Array(size);
new Array(element0, element1, ..., elementn);

参数
参数 size 是期望的数组元素个数。返回的数组，length 字段将被设为 size 的值。
参数 element ..., elementn 是参数列表。当使用这些参数来调用构造函数 Array() 时，新创建的数组的元素就会被初始化为这些值
。它的 length 字段也会被设置为参数的个数。
Array 对象属性
属性	描述
constructor	返回对创建此对象的数组函数的引用。
length	设置或返回数组中元素的数目。
prototype	使您有能力向对象添加属性和方法。

concat()	连接两个或更多的数组，并返回结果。
join()	把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。
pop()	删除并返回数组的最后一个元素
push()	向数组的末尾添加一个或更多元素，并返回新的长度。
reverse()	颠倒数组中元素的顺序。
shift()	删除并返回数组的第一个元素
slice()	从某个已有的数组返回选定的元素
sort()	对数组的元素进行排序
splice()	删除元素，并向数组添加新元素。
toSource()	返回该对象的源代码。
toString()	把数组转换为字符串，并返回结果。
toLocaleString()	把数组转换为本地数组，并返回结果。
unshift()	向数组的开头添加一个或更多元素，并返回新的长度。
valueOf()	返回数组对象的原始值

  //数组去掉重复
  var arr11 = [1,2,2,4,2];
  for(var i=0;i<arr11.length;i++){
    for(var j=i+1;j<arr11.length;j++){
	  if(arr11[i] == arr11[j]){
	    arr11.splice(j,1);
		j--;
	  }
	}
  }
  //alert(arr11);
  
  //排序
  var arr12 = ['c','d','a','e'];
  //arr12.sort();//按字符的编码的高低排序；
 // alert(arr12);
  
  var arr13 = [0,23,2,5,86,32,20,9,66,76];
  //arr13.sort(); //会把数字变成字符串 第一位比较 不支持056
  //alert(arr13);
  //比较函数
  arr13.sort(function(a,b){
    return a - b;
  });
  //alert(arr13)//从小到大排序 b-a 从大到小排序
  
  //快速排序法 希尔，谢尔 冒泡 归并 选择 插入 。。。
  
  var arrwidth = ['345px','23px','10px','1000px'];
  arrwidth.sort(function(a,b){
    return parseInt(a)-parseInt(b);
  }); 
  //alert(arrwidth); //10px 23px 345px 1000px
  
  //随机排序
  var arr14 = [1,2,3,4,5,6,7,8];
  arr14.sort(function(a,b){
    return Math.random()-0.1;
  });
  //alert(arr14);
  
  //随机函数
  //Math.round(Math.random()); 0~1
  //alert(Math.round(Math.random()))
  //alert(Math.round(3.5));  //4舍5入
  //alert(Math.round(Math.random()*10)); //0~10
  //alert(Math.round(Math.random()*5+5));//5~10;
 // alert(Math.round(Math.random()*10+10));//10~20;
  //alert(Math.round(Math.random()*80+20));//20~100
  //x~y Math.round(Math.random()*(y-x)+x));
  
  var x = 42;
  var y = 49;
  //alert(Math.round(Math.random()*(y-x)+x)); //42~49的随机数；
  
  //0~x
  var x1 = 3;
  //alert(Math.round(Math.random()*x1));
  
  //1~x
  var x2 = 3
  //alert(Math.ceil(Math.random()*x2));//ceil 向上取整

5 对象
对象
ECMA-262 把对象（object）定义为“属性的无序集合，每个属性存放一个原始值、对象或函数”。严格来说，这意味着对象是无特定顺序的值的数组。
类
每个对象都由类定义，可以把类看做对象的配方。类不仅要定义对象的接口（interface）（开发者访问的属性和方法），还要定义对象的内部工作
（使属性和方法发挥作用的代码）。编译器和解释程序都根据类的说明构建对象。

创建 JavaScript 对象
通过 JavaScript，您能够定义并创建自己的对象。
创建新对象有两种不同的方法：
定义并创建对象的实例
使用函数来定义对象，然后创建新的对象实例

JavaScript 类
JavaScript 是面向对象的语言，但 JavaScript 不使用类。
在 JavaScript 中，不会创建类，也不会通过类来创建对象（就像在其他面向对象的语言中那样）。
JavaScript 基于 prototype，而不是基于类的。
JavaScript for...in 循环
JavaScript for...in 语句循环遍历对象的属性。

ECMAScript 只有公用作用域
对 ECMAScript 讨论上面这些作用域几乎毫无意义，因为 ECMAScript 中只存在一种作用域 - 公用作用域。ECMAScript 中的所有对象的所有属性和
方法都是公用的。因此，定义自己的类和对象时，必须格外小心。记住，所有属性和方法默认都是公用的！
静态作用域
静态作用域定义的属性和方法任何时候都能从同一位置访问。在 Java 中，类可具有属性和方法，无需实例化该类的对象，即可访问这些属性和方法，例如 
java.net.URLEncoder 类，它的函数 encode() 就是静态方法

ECMAScript 没有静态作用域
严格来说，ECMAScript 并没有静态作用域。不过，它可以给构造函数提供属性和方法。还记得吗，构造函数只是函数。函数是对象，对象可以有属性和方法。例如：
function sayHello() {
  alert("hello");
}

sayHello.alternate = function() {
  alert("hi");
}

sayHello();		//输出 "hello"
sayHello.alternate();	//输出 "hi"

关键字 this
this 的功能
在 ECMAScript 中，要掌握的最重要的概念之一是关键字 this 的用法，它用在对象的方法中。关键字 this 总是指向调用该方法的对象，例如：
var oCar = new Object;
oCar.color = "red";
oCar.showColor = function() {
  alert(this.color);
};

oCar.showColor();		//输出 "red"

使用 this 的原因
为什么使用 this 呢？因为在实例化对象时，总是不能确定开发者会使用什么样的变量名。使用 this，即可在任何多个地方重用同一个函数。请思考下面的例子：
function showColor() {
  alert(this.color);
};

var oCar1 = new Object;
oCar1.color = "red";
oCar1.showColor = showColor;

var oCar2 = new Object;
oCar2.color = "blue";
oCar2.showColor = showColor;

oCar1.showColor();		//输出 "red"
oCar2.showColor();		//输出 "blue"
如果不用对象或 this 关键字引用变量，ECMAScript 就会把它看作局部变量或全局变量。然后该函数将查找名为 color 的局部或全局变量，但是不会找到。结果
如何呢？该函数将在警告中显示 "null"

6 循环，判断和运算符
运算符
JavaScript 算术运算符
算术运算符用于执行变量与/或值之间的算术运算。
给定 y=5，下面的表格解释了这些算术运算符：
运算符	描述	例子	结果
+	加	x=y+2	x=7
-	减	x=y-2	x=3
*	乘	x=y*2	x=10
/	除	x=y/2	x=2.5
%	求余数 (保留整数)	x=y%2	x=1
++	累加	x=++y	x=6
--	递减	x=--y	x=4

JavaScript 赋值运算符
赋值运算符用于给 JavaScript 变量赋值。
给定 x=10 和 y=5，下面的表格解释了赋值运算符：
运算符	例子	等价于	结果
=	x=y	 	x=5
+=	x+=y	x=x+y	x=15
-=	x-=y	x=x-y	x=5
*=	x*=y	x=x*y	x=50
/=	x/=y	x=x/y	x=2
%=	x%=y	x=x%y	x=0

用于字符串的 + 运算符
+ 运算符用于把文本值或字符串变量加起来（连接起来）。
如需把两个或多个字符串变量连接起来，请使用 + 运算符。

       1. for循环，需要知道数组的长度，才能遍历，
　　　　2. forEach循环，循环数组中每一个元素并采取操作， 没有返回值， 可以不用知道数组长度　
　　　　3. map函数，遍历数组每个元素，并回调操作，需要返回值，返回值组成新的数组，原数组不变
　　　　4. filter函数， 过滤通过条件的元素组成一个新数组， 原数组不变　　
　　　　5. some函数，遍历数组中是否有符合条件的元素，返回Boolean值
　　　　6. every函数， 遍历数组中是否每个元素都符合条件， 返回Boolean值
       7 除了遍历数组之外，还有遍历对象，常用方法  for in
　　　　　in 不仅可以用来 遍历对象，还可以用来遍历数组， 不过 i 对应与数组的 key值

利用sort把下面的arr1数组中的对象排序
var arr1 = [
    {name: 'te', value: 5},
    {name: 'te', value: 2},
    {name: 'we', value: 3},
    {name: 'ee', value: 1},
    {name: 'ee', value: 4}
];
 
var by = function(type){
    return function(o,p){
        console.log(o,p);
        var a;
        var b;
        if(typeof o === 'object' && typeof p === 'object' && o && p){
            a = o[type];
            b = p[type];
            if(a === b) {
                return 0;
            }
            if(typeof a === typeof b){
            console.log(a, b);
                return a < b ? -1 : 1
            }
            return typeof a < typeof b ? -1 : 1;
        }else {
            throw('字段有误');
        }
    }
}
console.log(arr1.sort(by('value')));

 后台传过来的数组中，每个对象按 value 排序, value > 5的按顺序排在前面，小于5排在后面
思考后， 可以在原来的的方法中这样写,将数组分成2段，大于等于5和小于5，交换位置即可
var arr1 = [
    {name: 'te', value: 5},
    {name: 'te', value: 2},
    {name: 'we', value: 3},
    {name: 'ee', value: 1},
    {name: 'ee', value: 4}
];
 
var sortObj = function(arr, type , num){
    var by = function(type){
        return function(o,p){
            var a;
            var b;
            if(typeof o === 'object' && typeof p === 'object' && o && p){
                a = o[type];
                b = p[type];
                if(a === b) {
                    return 0;
                }
                if(typeof a === typeof b){
                console.log(a, b);
                    return a < b ? -1 : 1
                }
                return typeof a < typeof b ? -1 : 1;
            }else {
                throw('字段有误');
            }
        }
    };
 
    var cacheArr = arr.sort(by('value'));
 
    //通过num 把数组分成两段
    var arrBf = cacheArr.filter(function(item){
        if(item.value < num){
            return item;
        }
    });
    var arrAf = cacheArr.filter(function(item){
        if(item.value >= num){
            return item;
        }
    });
 
    //交换位置 即可得到
    var newArr = arrAf.concat(arrBf);
    return newArr;
};
console.log(sortObj(arr1, 'value' , 3));

7 定时器

8 函数 及 作用域

9 面向对象







