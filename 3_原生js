1 基本数据类型
  数字 Number 
    八进制数和十六进制数
    浮点数
      要定义浮点值，必须包括小数点和小数点后的一位数字（例如，用 1.0 而不是 1）。这被看作浮点数字面量。
    特殊的 Number 
       几个特殊值也被定义为 Number 类型。前两个是 Number.MAX_VALUE 和 Number.MIN_VALUE，它们定义了 Number 值集合的外边界。所有 ECMAScript
       数都必须在这两个值之间。不过计算生成的数值结果可以不落在这两个值之间。
      当计算生成的数大于 Number.MAX_VALUE 时，它将被赋予值 Number.POSITIVE_INFINITY，意味着不再有数字值。同样，生成的数值小于 
      Number.MIN_VALUE 的计算也会被赋予值 Number.NEGATIVE_INFINITY，也意味着不再有数字值。如果计算返回的是无穷大值，那么生成的结果不能再用
      于其他计算。
      事实上，有专门的值表示无穷大，（如你猜到的）即 Infinity。Number.POSITIVE_INFINITY 的值为 Infinity。Number.NEGATIVE_INFINITY 的值为
      -Infinity。
     由于无穷大数可以是正数也可以是负数，所以可用一个方法判断一个数是否是有穷的（而不是单独测试每个无穷数）。可以对任何数调用 isFinite() 方法
     ，以确保该数不是无穷大。
     特殊值  NAN
     
  布尔值 booleans  值为true 或false
    Boolean 类型是 ECMAScript 中最常用的类型之一。它有两个值 true 和 false （即两个 Boolean 字面量）。
    即使 false 不等于 0，0 也可以在必要时被转换成 false，这样在 Boolean 语句中使用两者都是安全的
    
  空 null  object - 如果变量是一种引用类型或 Null 类型的
    typeof 运算符对于 null 值会返回 "Object"。这实际上是 JavaScript 最初实现中的一个错误，然后被 ECMAScript 沿用了。现在，null 被认为是对象的
    占位符，从而解释了这一矛盾，但从技术上来说，它仍然是原始值。
    alert(null == undefined);  //输出 "true"
    
  未定义 undefined
    当声明的变量未初始化时，该变量的默认值是 undefined
    var oTemp;
    前面一行代码声明变量 oTemp，没有初始值。该变量将被赋予值 undefined，即 undefined 类型的字面量。可以用下面的代码段测试该变量的值是否等于
    undefined：
    var oTemp;  alert(oTemp == undefined);
    这段代码将显示 "true"，说明这两个值确实相等。还可以用 typeof 运算符显示该变量的值是 undefined：
    var oTemp;  alert(typeof oTemp); //输出 "undefined"
    提示：值 undefined 并不同于未定义的值。但是，typeof 运算符并不真正区分这两种值。考虑下面的代码：
    var oTemp;

    alert(typeof oTemp);  //输出 "undefined"
    alert(typeof oTemp2);  //输出 "undefined"
    前面的代码对两个变量输出的都是 "undefined"，即使只有变量 oTemp2 从未被声明过。如果对 oTemp2 使用除 typeof 之外的其他运算符的话，会引起
    错误，因为其他运算符只能用于已声明的变量上。
    例如，下面的代码将引发错误：
    var oTemp;  alert(oTemp2 == undefined);
    当函数无明确返回值时，返回的也是值 "undefined"，如下所示：
    function testFunc() {
    }

    alert(testFunc() == undefined); //输出 "true"
    
  字符串 string
    String 类型的独特之处在于，它是唯一没有固定大小的原始类型。可以用字符串存储 0 或更多的 Unicode 字符，有 16 位整数表示（Unicode 是一种
    国际字符集，本教程后面将讨论它）。
    字符串中每个字符都有特定的位置，首字符从位置 0 开始，第二个字符在位置 1，依此类推。这意味着字符串中的最后一个字符的位置一定是字符串的长度减 1：
    字符串字面量是由双引号（"）或单引号（'）声明的。而 Java 则是用双引号声明字符串，用单引号声明字符。但是由于 ECMAScript 没有字符类型，所以
    可使用这两种表示法中的任何一种
    
  判断数据类型  typeof 其中 判断未定义的数据类型不安全
  
\n
换行
\t
制表符
\b
空格
\r
回车
\f
换页符
\\
反斜杠
\'
单引号
\"
双引号
\0nnn
八进制代码 nnn 表示的字符（n 是 0 到 7 中的一个八进制数字）
\xnn
十六进制代码 nn 表示的字符（n 是 0 到 F 中的一个十六进制数字）
\unnnn
十六进制代码 nnnn 表示的 Unicode 字符（n 是 0 到 F 中的一个十六进制数字）


2 数据类型
   字符串  数组  object  json

3 字符串
    创建 String 对象的语法：
    new String(s);
    String(s);
    参数
    参数 s 是要存储在 String 对象中或转换成原始字符串的值。
    返回值
    当 String() 和运算符 new 一起作为构造函数使用时，它返回一个新创建的 String 对象，存放的是字符串 s 或 s 的字符串表示。
    当不用 new 运算符调用 String() 时，它只把 s 转换成原始的字符串，并返回转换后的值。
    String 对象属性
    属性	描述
    constructor	对创建该对象的函数的引用
    length	字符串的长度
    prototype	允许您向对象添加属性和方法
anchor()	创建 HTML 锚。
big()	用大号字体显示字符串。
blink()	显示闪动字符串。
bold()	使用粗体显示字符串。
charAt()	返回在指定位置的字符。
charCodeAt()	返回在指定的位置的字符的 Unicode 编码。
concat()	连接字符串。
fixed()	以打字机文本显示字符串。
fontcolor()	使用指定的颜色来显示字符串。
fontsize()	使用指定的尺寸来显示字符串。
fromCharCode()	从字符编码创建一个字符串。
indexOf()	检索字符串。
italics()	使用斜体显示字符串。
lastIndexOf()	从后向前搜索字符串。
link()	将字符串显示为链接。
localeCompare()	用本地特定的顺序来比较两个字符串。
match()	找到一个或多个正则表达式的匹配。
replace()	替换与正则表达式匹配的子串。
search()	检索与正则表达式相匹配的值。
slice()	提取字符串的片断，并在新的字符串中返回被提取的部分。
small()	使用小字号来显示字符串。
split()	把字符串分割为字符串数组。
strike()	使用删除线来显示字符串。
sub()	把字符串显示为下标。
substr()	从起始索引号提取字符串中指定数目的字符。
substring()	提取字符串中两个指定的索引号之间的字符。
sup()	把字符串显示为上标。
toLocaleLowerCase()	把字符串转换为小写。
toLocaleUpperCase()	把字符串转换为大写。
toLowerCase()	把字符串转换为小写。
toUpperCase()	把字符串转换为大写。
toSource()	代表对象的源代码。
toString()	返回字符串。
valueOf()	返回某个字符串对象的原始值



4 数组
创建 Array 对象的语法：
new Array();
new Array(size);
new Array(element0, element1, ..., elementn);

参数
参数 size 是期望的数组元素个数。返回的数组，length 字段将被设为 size 的值。
参数 element ..., elementn 是参数列表。当使用这些参数来调用构造函数 Array() 时，新创建的数组的元素就会被初始化为这些值
。它的 length 字段也会被设置为参数的个数。
Array 对象属性
属性	描述
constructor	返回对创建此对象的数组函数的引用。
length	设置或返回数组中元素的数目。
prototype	使您有能力向对象添加属性和方法。

concat()	连接两个或更多的数组，并返回结果。
join()	把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。
pop()	删除并返回数组的最后一个元素
push()	向数组的末尾添加一个或更多元素，并返回新的长度。
reverse()	颠倒数组中元素的顺序。
shift()	删除并返回数组的第一个元素
slice()	从某个已有的数组返回选定的元素
sort()	对数组的元素进行排序
splice()	删除元素，并向数组添加新元素。
toSource()	返回该对象的源代码。
toString()	把数组转换为字符串，并返回结果。
toLocaleString()	把数组转换为本地数组，并返回结果。
unshift()	向数组的开头添加一个或更多元素，并返回新的长度。
valueOf()	返回数组对象的原始值

  //数组去掉重复
  var arr11 = [1,2,2,4,2];
  for(var i=0;i<arr11.length;i++){
    for(var j=i+1;j<arr11.length;j++){
	  if(arr11[i] == arr11[j]){
	    arr11.splice(j,1);
		j--;
	  }
	}
  }
  //alert(arr11);
  
  //排序
  var arr12 = ['c','d','a','e'];
  //arr12.sort();//按字符的编码的高低排序；
 // alert(arr12);
  
  var arr13 = [0,23,2,5,86,32,20,9,66,76];
  //arr13.sort(); //会把数字变成字符串 第一位比较 不支持056
  //alert(arr13);
  //比较函数
  arr13.sort(function(a,b){
    return a - b;
  });
  //alert(arr13)//从小到大排序 b-a 从大到小排序
  
  //快速排序法 希尔，谢尔 冒泡 归并 选择 插入 。。。
  
  var arrwidth = ['345px','23px','10px','1000px'];
  arrwidth.sort(function(a,b){
    return parseInt(a)-parseInt(b);
  }); 
  //alert(arrwidth); //10px 23px 345px 1000px
  
  //随机排序
  var arr14 = [1,2,3,4,5,6,7,8];
  arr14.sort(function(a,b){
    return Math.random()-0.1;
  });
  //alert(arr14);
  
  //随机函数
  //Math.round(Math.random()); 0~1
  //alert(Math.round(Math.random()))
  //alert(Math.round(3.5));  //4舍5入
  //alert(Math.round(Math.random()*10)); //0~10
  //alert(Math.round(Math.random()*5+5));//5~10;
 // alert(Math.round(Math.random()*10+10));//10~20;
  //alert(Math.round(Math.random()*80+20));//20~100
  //x~y Math.round(Math.random()*(y-x)+x));
  
  var x = 42;
  var y = 49;
  //alert(Math.round(Math.random()*(y-x)+x)); //42~49的随机数；
  
  //0~x
  var x1 = 3;
  //alert(Math.round(Math.random()*x1));
  
  //1~x
  var x2 = 3
  //alert(Math.ceil(Math.random()*x2));//ceil 向上取整

5 对象
对象
ECMA-262 把对象（object）定义为“属性的无序集合，每个属性存放一个原始值、对象或函数”。严格来说，这意味着对象是无特定顺序的值的数组。
类
每个对象都由类定义，可以把类看做对象的配方。类不仅要定义对象的接口（interface）（开发者访问的属性和方法），还要定义对象的内部工作
（使属性和方法发挥作用的代码）。编译器和解释程序都根据类的说明构建对象。

创建 JavaScript 对象
通过 JavaScript，您能够定义并创建自己的对象。
创建新对象有两种不同的方法：
定义并创建对象的实例
使用函数来定义对象，然后创建新的对象实例

JavaScript 类
JavaScript 是面向对象的语言，但 JavaScript 不使用类。
在 JavaScript 中，不会创建类，也不会通过类来创建对象（就像在其他面向对象的语言中那样）。
JavaScript 基于 prototype，而不是基于类的。
JavaScript for...in 循环
JavaScript for...in 语句循环遍历对象的属性。

ECMAScript 只有公用作用域
对 ECMAScript 讨论上面这些作用域几乎毫无意义，因为 ECMAScript 中只存在一种作用域 - 公用作用域。ECMAScript 中的所有对象的所有属性和
方法都是公用的。因此，定义自己的类和对象时，必须格外小心。记住，所有属性和方法默认都是公用的！
静态作用域
静态作用域定义的属性和方法任何时候都能从同一位置访问。在 Java 中，类可具有属性和方法，无需实例化该类的对象，即可访问这些属性和方法，例如 
java.net.URLEncoder 类，它的函数 encode() 就是静态方法

ECMAScript 没有静态作用域
严格来说，ECMAScript 并没有静态作用域。不过，它可以给构造函数提供属性和方法。还记得吗，构造函数只是函数。函数是对象，对象可以有属性和方法。例如：
function sayHello() {
  alert("hello");
}

sayHello.alternate = function() {
  alert("hi");
}

sayHello();		//输出 "hello"
sayHello.alternate();	//输出 "hi"

关键字 this
this 的功能
在 ECMAScript 中，要掌握的最重要的概念之一是关键字 this 的用法，它用在对象的方法中。关键字 this 总是指向调用该方法的对象，例如：
var oCar = new Object;
oCar.color = "red";
oCar.showColor = function() {
  alert(this.color);
};

oCar.showColor();		//输出 "red"

使用 this 的原因
为什么使用 this 呢？因为在实例化对象时，总是不能确定开发者会使用什么样的变量名。使用 this，即可在任何多个地方重用同一个函数。请思考下面的例子：
function showColor() {
  alert(this.color);
};

var oCar1 = new Object;
oCar1.color = "red";
oCar1.showColor = showColor;

var oCar2 = new Object;
oCar2.color = "blue";
oCar2.showColor = showColor;

oCar1.showColor();		//输出 "red"
oCar2.showColor();		//输出 "blue"
如果不用对象或 this 关键字引用变量，ECMAScript 就会把它看作局部变量或全局变量。然后该函数将查找名为 color 的局部或全局变量，但是不会找到。结果
如何呢？该函数将在警告中显示 "null"

6 循环，判断和运算符
运算符
JavaScript 算术运算符
算术运算符用于执行变量与/或值之间的算术运算。
给定 y=5，下面的表格解释了这些算术运算符：
运算符	描述	例子	结果
+	加	x=y+2	x=7
-	减	x=y-2	x=3
*	乘	x=y*2	x=10
/	除	x=y/2	x=2.5
%	求余数 (保留整数)	x=y%2	x=1
++	累加	x=++y	x=6
--	递减	x=--y	x=4

JavaScript 赋值运算符
赋值运算符用于给 JavaScript 变量赋值。
给定 x=10 和 y=5，下面的表格解释了赋值运算符：
运算符	例子	等价于	结果
=	x=y	 	x=5
+=	x+=y	x=x+y	x=15
-=	x-=y	x=x-y	x=5
*=	x*=y	x=x*y	x=50
/=	x/=y	x=x/y	x=2
%=	x%=y	x=x%y	x=0

用于字符串的 + 运算符
+ 运算符用于把文本值或字符串变量加起来（连接起来）。
如需把两个或多个字符串变量连接起来，请使用 + 运算符。

       1. for循环，需要知道数组的长度，才能遍历，
　　　　2. forEach循环，循环数组中每一个元素并采取操作， 没有返回值， 可以不用知道数组长度　
　　　　3. map函数，遍历数组每个元素，并回调操作，需要返回值，返回值组成新的数组，原数组不变
　　　　4. filter函数， 过滤通过条件的元素组成一个新数组， 原数组不变　　
　　　　5. some函数，遍历数组中是否有符合条件的元素，返回Boolean值
　　　　6. every函数， 遍历数组中是否每个元素都符合条件， 返回Boolean值
       7 除了遍历数组之外，还有遍历对象，常用方法  for in
　　　　　in 不仅可以用来 遍历对象，还可以用来遍历数组， 不过 i 对应与数组的 key值

利用sort把下面的arr1数组中的对象排序
var arr1 = [
    {name: 'te', value: 5},
    {name: 'te', value: 2},
    {name: 'we', value: 3},
    {name: 'ee', value: 1},
    {name: 'ee', value: 4}
];
 
var by = function(type){
    return function(o,p){
        console.log(o,p);
        var a;
        var b;
        if(typeof o === 'object' && typeof p === 'object' && o && p){
            a = o[type];
            b = p[type];
            if(a === b) {
                return 0;
            }
            if(typeof a === typeof b){
            console.log(a, b);
                return a < b ? -1 : 1
            }
            return typeof a < typeof b ? -1 : 1;
        }else {
            throw('字段有误');
        }
    }
}
console.log(arr1.sort(by('value')));

 后台传过来的数组中，每个对象按 value 排序, value > 5的按顺序排在前面，小于5排在后面
思考后， 可以在原来的的方法中这样写,将数组分成2段，大于等于5和小于5，交换位置即可
var arr1 = [
    {name: 'te', value: 5},
    {name: 'te', value: 2},
    {name: 'we', value: 3},
    {name: 'ee', value: 1},
    {name: 'ee', value: 4}
];
 
var sortObj = function(arr, type , num){
    var by = function(type){
        return function(o,p){
            var a;
            var b;
            if(typeof o === 'object' && typeof p === 'object' && o && p){
                a = o[type];
                b = p[type];
                if(a === b) {
                    return 0;
                }
                if(typeof a === typeof b){
                console.log(a, b);
                    return a < b ? -1 : 1
                }
                return typeof a < typeof b ? -1 : 1;
            }else {
                throw('字段有误');
            }
        }
    };
 
    var cacheArr = arr.sort(by('value'));
 
    //通过num 把数组分成两段
    var arrBf = cacheArr.filter(function(item){
        if(item.value < num){
            return item;
        }
    });
    var arrAf = cacheArr.filter(function(item){
        if(item.value >= num){
            return item;
        }
    });
 
    //交换位置 即可得到
    var newArr = arrAf.concat(arrBf);
    return newArr;
};
console.log(sortObj(arr1, 'value' , 3));

7 定时器

定时器的写法
setInterval(expression,milliseconds)；
setTimeout(expression,milliseconds)；
上式中，expression既可以是字符串，也可以是匿名函数，或者也可以是一个函数名。但是，函数名中不能传参。第二个参数为延迟要执行的时间。
具体写法如下：
（1）函数名，不带参数
setInterval(test,1000)；           //1秒后执行
（2）字符串，可以执行的代码
setInterval('test()',1000)；       //1秒后执行
（3）匿名函数
setInterval(function(){},1000)；   //1秒后执行
（4）调用函数
setInterval(test,1000)；           //立即执行

定时器的写法
setInterval(expression,milliseconds)；
setTimeout(expression,milliseconds)；
上式中，expression既可以是字符串，也可以是匿名函数，或者也可以是一个函数名。但是，函数名中不能传参。第二个参数为延迟要执行的时间。
具体写法如下：
（1）函数名，不带参数
setInterval(test,1000)；           //1秒后执行
（2）字符串，可以执行的代码
setInterval('test()',1000)；       //1秒后执行
（3）匿名函数
setInterval(function(){},1000)；   //1秒后执行
（4）调用函数
setInterval(test,1000)；           //立即执行

如果没有特殊指向，setInterval和setTimeout的回调函数中this的指向都是window。这是因为JS的定时器方法是定义在window下的。但是平时很多场景下，
都需要修改this的指向。这里总结了几种：

1、最常用的方法：在外部函数中将this存为一个变量，回调函数中使用该变量，而不是直接使用this。


 1 var name = 'my name is window';
 2 var obj = {
 3     name: 'my name is obj',
 4     fn: function () {
 5         var that = this;
 6         var timer = null;
 7         clearInterval(timer);
 8         timer = setInterval(function () {
 9             console.log(that.name);   //my name is obj
10         }, 1000)
11     }
12 }

在fn中加了var that = this; 回调函数中使用that代替this即可。这种方法最常见，使用也最广泛。

2、使用bind()方法（bind()为ES5的标准，低版本IE下有兼容问题，可以引入es5-shim.js解决）

bind()的作用类似call和apply，都是修改this指向。但是call和apply是修改this指向后函数会立即执行，而bind则是返回一个新的函数，它会创建一个与原
来函数主体相同的新函数，新函数中的this指向传入的对象。


 1 var name = 'my name is window';
 2 var obj = {
 3     name: 'my name is obj',
 4     fn: function () {
 5         var timer = null;
 6         clearInterval(timer);
 7         timer = setInterval(function () {
 8             console.log(this.name);   //my name is obj
 9         }.bind(this), 1000)
10     }
11 }

在这里为什么不能用call和apply，是因为call和apply不是返回函数，而是立即执行函数，那么，就失去了定时器的作用。

3、使用es6的箭头函数：箭头函数的最大作用就是this指向。


 1 var name = 'my name is window';
 2 var obj = {
 3     name: 'my name is obj',
 4     fn: function () {
 5         var timer = null;
 6         clearInterval(timer);
 7         timer = setInterval(() => {
 8             console.log(this.name);  //my name is obj
 9         }, 1000)
10     }
11 }

requestAnimationFrame 比起 setTimeout、setInterval的优势主要有两点：
1、requestAnimationFrame 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，
一般来说，这个频率为每秒60帧。
2、在隐藏或不可见的元素中，requestAnimationFrame将不会进行重绘或回流，这当然就意味着更少的的cpu，gpu和内存使用量。
cancelAnimationFrame函数来取消requestAnimationFrame的回调

8 函数 及 作用域

JavaScript 函数语法
函数就是包裹在花括号中的代码块，前面使用了关键词 function：
function functionname()
{
这里是要执行的代码
}
当调用该函数时，会执行函数内的代码。
可以在某事件发生时直接调用函数（比如当用户点击按钮时），并且可由 JavaScript 在任何位置进行调用。
提示：JavaScript 对大小写敏感。关键词 function 必须是小写的，并且必须以与函数名称相同的大小写来调用函数。
调用带参数的函数
在调用函数时，您可以向其传递值，这些值被称为参数。
这些参数可以在函数中使用。
您可以发送任意多的参数，由逗号 (,) 分隔：
myFunction(argument1,argument2)
当您声明函数时，请把参数作为变量来声明：
function myFunction(var1,var2)
{
这里是要执行的代码
}
变量和参数必须以一致的顺序出现。第一个变量就是第一个被传递的参数的给定的值，以此类推。
实例
<button onclick="myFunction('Bill Gates','CEO')">点击这里</button>

<script>
function myFunction(name,job)
{
alert("Welcome " + name + ", the " + job);
}
</script>

带有返回值的函数
有时，我们会希望函数将值返回调用它的地方。
通过使用 return 语句就可以实现。
在使用 return 语句时，函数会停止执行，并返回指定的值。
语法
function myFunction()
{
var x=5;
return x;
}
上面的函数会返回值 5。
注释：整个 JavaScript 并不会停止执行，仅仅是函数。JavaScript 将继续执行代码，从调用函数的地方。
函数调用将被返回值取代：
var myVar=myFunction();
myVar 变量的值是 5，也就是函数 "myFunction()" 所返回的值。
即使不把它保存为变量，您也可以使用返回值：
document.getElementById("demo").innerHTML=myFunction();
"demo" 元素的 innerHTML 将成为 5，也就是函数 "myFunction()" 所返回的值。
您可以使返回值基于传递到函数中的参数：
实例
计算两个数字的乘积，并返回结果：
function myFunction(a,b)
{
return a*b;
}

document.getElementById("demo").innerHTML=myFunction(4,3);
"demo" 元素的 innerHTML 将是：
12
亲自试一试
在您仅仅希望退出函数时 ，也可使用 return 语句。返回值是可选的：
function myFunction(a,b)
{
if (a>b)
  {
  return;
  }
x=a+b
}
如果 a 大于 b，则上面的代码将退出函数，并不会计算 a 和 b 的总和。
局部 JavaScript 变量
在 JavaScript 函数内部声明的变量（使用 var）是局部变量，所以只能在函数内部访问它。（该变量的作用域是局部的）。
您可以在不同的函数中使用名称相同的局部变量，因为只有声明过该变量的函数才能识别出该变量。
只要函数运行完毕，本地变量就会被删除。
全局 JavaScript 变量
在函数外声明的变量是全局变量，网页上的所有脚本和函数都能访问它。
JavaScript 变量的生存期
JavaScript 变量的生命期从它们被声明的时间开始。
局部变量会在函数运行以后被删除。
全局变量会在页面关闭后被删除。
向未声明的 JavaScript 变量来分配值
如果您把值赋给尚未声明的变量，该变量将被自动作为全局变量声明。
这条语句：
carname="Volvo";
将声明一个全局变量 carname，即使它在函数内执行。

1.函数声明

function sum1(n1,n2){
    return n1+n2;
  };
2.函数表达式，又叫函数字面量

var sum2=function(n1,n2){
    return n1+n2;
};
两者的区别：解析器会先读取函数声明，并使其在执行任何代码之前可以访问；而函数表达式则必须等到解析器执行到它所在的代码行才会真正被解释执行。
自执行函数严格来说也叫函数表达式，它主要用于创建一个新的作用域，在此作用域内声明的变量，不会和其它作用域内的变量冲突或混淆，大多是以匿名函
数方式存在，且立即自动执行。

(function(n1,n2){
    console.log (n1+n2)
})(1,3);//4

另外几种自执行函数：
//可用来传参
(function(x,y){
  console.log(x+y);
})(2,3);
 
//带返回值
var sum=(function(x,y){
  return x+y;
})(2,3);
console.log(sum);
 
~function(){
  var name='~'
  console.log(name);
}();
 
!function(){
  var name='!'
  console.log(name);
}();
 
;(function(){
  var name=';'
  console.log(name);
})();
 
-function(){
  var name='-'
  console.log(name);
}();
 
//逗号运算符
1,function(){
  var name=',';
  console.log(name);
}();
 
//异或
1^function(){
  var name='^';
  console.log(name);
}();
 
//比较运算符
1>function(){
  var name='>';
  console.log(name);
}();
 
~+-!(function(){
  var name='~+-!';
  console.log(name);
})();
 
~!(function(){
  var name='~!';
  console.log(name);
})();
 
(function(){
  var name='call';
  console.log(name);
}).call();
 
(function(){
  var name='apply';
  console.log(name);
}).apply();

3.函数构造法，参数必须加引号


var sum3=new Function('n1','n2','return n1+n2');
console.log(sum3(2,3));//5
从技术角度讲，这是一个函数表达式。一般不推荐用这种方法定义函数，因为这种语法会导致解析两次代码（第一次是解析常规ECMAScript代码，第二次是解析
传入构造函数中的字符串），从而影响性能。

var name='haoxl';
  function fun(){
    var name='lili';
    return new Function('return name');//不能获取局部变量
  }
 console.log(fun()());//haoxl
 Function()构造函数每次执行时都会解析函数主体，并创建一个新的函数对象，所以当在一个循环或频繁执行的函数中调用Function()构造函数效率是非常低的。
 而函数字面量却不是每次遇到都会重新编译的，用Function()构造函数创建一个函数时并不遵循典型的作用域，它一直把它当作是顶级函数来执行。
 
 4 作为函数方法调用函数：(这种可以设置this的值，我可以返回不同this！)
   在js中函数是对象，是对象就有属性个方法，而call（）和apply（）是预定义的函数方法！
   这两个方法都可以调用函数，两个方法的第一个参数必须是对象的本身！
   
如果想要对函数有更深刻的理解，或者正确认识函数！需要我们先做一件事，那就是了解js的运行机制问题：
        1、在js中js引擎会优先解析var变量和function定义！在预解析完成后从上到下逐步进行！
        2、解析var变量时，会把值存储在“执行环境”中，而不会去赋值，值是存储作用！例如:
        alert（a）;  var a = 5;  这时会输出undifiend,意思是没有被初始化没有被赋值!
        这并不是没有被定义，错误了的意思！
        3、在解析function时会把函数整体定义，这也就解释了为什么在function定义函数时为什么可以先调用后声明了！其实表面上看是先调用了，其实在内部机
	制中第一步实行的是把以function方式定义的函数先声明了！

javascrit中函数有一个内置的对象arguments对象！
      作用是：1.在js中函数定义没有任何参数，调用该函数时可以传递任意参数！
      2.arguments对象是数组对象。
      3.arguments对象的length属性：获取函数的实参个数！
      4.利用Arguments对象特性,实现模拟函数的重载的效果.
	

9 面向对象







