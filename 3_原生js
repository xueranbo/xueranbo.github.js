1 基本数据类型
  数字 Number 
    八进制数和十六进制数
    浮点数
      要定义浮点值，必须包括小数点和小数点后的一位数字（例如，用 1.0 而不是 1）。这被看作浮点数字面量。
    特殊的 Number 
       几个特殊值也被定义为 Number 类型。前两个是 Number.MAX_VALUE 和 Number.MIN_VALUE，它们定义了 Number 值集合的外边界。所有 ECMAScript
       数都必须在这两个值之间。不过计算生成的数值结果可以不落在这两个值之间。
      当计算生成的数大于 Number.MAX_VALUE 时，它将被赋予值 Number.POSITIVE_INFINITY，意味着不再有数字值。同样，生成的数值小于 
      Number.MIN_VALUE 的计算也会被赋予值 Number.NEGATIVE_INFINITY，也意味着不再有数字值。如果计算返回的是无穷大值，那么生成的结果不能再用
      于其他计算。
      事实上，有专门的值表示无穷大，（如你猜到的）即 Infinity。Number.POSITIVE_INFINITY 的值为 Infinity。Number.NEGATIVE_INFINITY 的值为
      -Infinity。
     由于无穷大数可以是正数也可以是负数，所以可用一个方法判断一个数是否是有穷的（而不是单独测试每个无穷数）。可以对任何数调用 isFinite() 方法
     ，以确保该数不是无穷大。
     特殊值  NAN
     
  布尔值 booleans  值为true 或false
    Boolean 类型是 ECMAScript 中最常用的类型之一。它有两个值 true 和 false （即两个 Boolean 字面量）。
    即使 false 不等于 0，0 也可以在必要时被转换成 false，这样在 Boolean 语句中使用两者都是安全的
    
  空 null  object - 如果变量是一种引用类型或 Null 类型的
    typeof 运算符对于 null 值会返回 "Object"。这实际上是 JavaScript 最初实现中的一个错误，然后被 ECMAScript 沿用了。现在，null 被认为是对象的
    占位符，从而解释了这一矛盾，但从技术上来说，它仍然是原始值。
    alert(null == undefined);  //输出 "true"
    
  未定义 undefined
    当声明的变量未初始化时，该变量的默认值是 undefined
    var oTemp;
    前面一行代码声明变量 oTemp，没有初始值。该变量将被赋予值 undefined，即 undefined 类型的字面量。可以用下面的代码段测试该变量的值是否等于
    undefined：
    var oTemp;  alert(oTemp == undefined);
    这段代码将显示 "true"，说明这两个值确实相等。还可以用 typeof 运算符显示该变量的值是 undefined：
    var oTemp;  alert(typeof oTemp); //输出 "undefined"
    提示：值 undefined 并不同于未定义的值。但是，typeof 运算符并不真正区分这两种值。考虑下面的代码：
    var oTemp;

    alert(typeof oTemp);  //输出 "undefined"
    alert(typeof oTemp2);  //输出 "undefined"
    前面的代码对两个变量输出的都是 "undefined"，即使只有变量 oTemp2 从未被声明过。如果对 oTemp2 使用除 typeof 之外的其他运算符的话，会引起
    错误，因为其他运算符只能用于已声明的变量上。
    例如，下面的代码将引发错误：
    var oTemp;  alert(oTemp2 == undefined);
    当函数无明确返回值时，返回的也是值 "undefined"，如下所示：
    function testFunc() {
    }

    alert(testFunc() == undefined); //输出 "true"
    
  字符串 string
    String 类型的独特之处在于，它是唯一没有固定大小的原始类型。可以用字符串存储 0 或更多的 Unicode 字符，有 16 位整数表示（Unicode 是一种
    国际字符集，本教程后面将讨论它）。
    字符串中每个字符都有特定的位置，首字符从位置 0 开始，第二个字符在位置 1，依此类推。这意味着字符串中的最后一个字符的位置一定是字符串的长度减 1：
    字符串字面量是由双引号（"）或单引号（'）声明的。而 Java 则是用双引号声明字符串，用单引号声明字符。但是由于 ECMAScript 没有字符类型，所以
    可使用这两种表示法中的任何一种
    
  判断数据类型  typeof 其中 判断未定义的数据类型不安全
  
\n
换行
\t
制表符
\b
空格
\r
回车
\f
换页符
\\
反斜杠
\'
单引号
\"
双引号
\0nnn
八进制代码 nnn 表示的字符（n 是 0 到 7 中的一个八进制数字）
\xnn
十六进制代码 nn 表示的字符（n 是 0 到 F 中的一个十六进制数字）
\unnnn
十六进制代码 nnnn 表示的 Unicode 字符（n 是 0 到 F 中的一个十六进制数字）


2 数据类型
   字符串  数组  object  json

3 字符串
    创建 String 对象的语法：
    new String(s);
    String(s);
    参数
    参数 s 是要存储在 String 对象中或转换成原始字符串的值。
    返回值
    当 String() 和运算符 new 一起作为构造函数使用时，它返回一个新创建的 String 对象，存放的是字符串 s 或 s 的字符串表示。
    当不用 new 运算符调用 String() 时，它只把 s 转换成原始的字符串，并返回转换后的值。
    String 对象属性
    属性	描述
    constructor	对创建该对象的函数的引用
    length	字符串的长度
    prototype	允许您向对象添加属性和方法
anchor()	创建 HTML 锚。
big()	用大号字体显示字符串。
blink()	显示闪动字符串。
bold()	使用粗体显示字符串。
charAt()	返回在指定位置的字符。
charCodeAt()	返回在指定的位置的字符的 Unicode 编码。
concat()	连接字符串。
fixed()	以打字机文本显示字符串。
fontcolor()	使用指定的颜色来显示字符串。
fontsize()	使用指定的尺寸来显示字符串。
fromCharCode()	从字符编码创建一个字符串。
indexOf()	检索字符串。
italics()	使用斜体显示字符串。
lastIndexOf()	从后向前搜索字符串。
link()	将字符串显示为链接。
localeCompare()	用本地特定的顺序来比较两个字符串。
match()	找到一个或多个正则表达式的匹配。
replace()	替换与正则表达式匹配的子串。
search()	检索与正则表达式相匹配的值。
slice()	提取字符串的片断，并在新的字符串中返回被提取的部分。
small()	使用小字号来显示字符串。
split()	把字符串分割为字符串数组。
strike()	使用删除线来显示字符串。
sub()	把字符串显示为下标。
substr()	从起始索引号提取字符串中指定数目的字符。
substring()	提取字符串中两个指定的索引号之间的字符。
sup()	把字符串显示为上标。
toLocaleLowerCase()	把字符串转换为小写。
toLocaleUpperCase()	把字符串转换为大写。
toLowerCase()	把字符串转换为小写。
toUpperCase()	把字符串转换为大写。
toSource()	代表对象的源代码。
toString()	返回字符串。
valueOf()	返回某个字符串对象的原始值



4 数组
创建 Array 对象的语法：
new Array();
new Array(size);
new Array(element0, element1, ..., elementn);

参数
参数 size 是期望的数组元素个数。返回的数组，length 字段将被设为 size 的值。
参数 element ..., elementn 是参数列表。当使用这些参数来调用构造函数 Array() 时，新创建的数组的元素就会被初始化为这些值
。它的 length 字段也会被设置为参数的个数。
Array 对象属性
属性	描述
constructor	返回对创建此对象的数组函数的引用。
length	设置或返回数组中元素的数目。
prototype	使您有能力向对象添加属性和方法。

concat()	连接两个或更多的数组，并返回结果。
join()	把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。
pop()	删除并返回数组的最后一个元素
push()	向数组的末尾添加一个或更多元素，并返回新的长度。
reverse()	颠倒数组中元素的顺序。
shift()	删除并返回数组的第一个元素
slice()	从某个已有的数组返回选定的元素
sort()	对数组的元素进行排序
splice()	删除元素，并向数组添加新元素。
toSource()	返回该对象的源代码。
toString()	把数组转换为字符串，并返回结果。
toLocaleString()	把数组转换为本地数组，并返回结果。
unshift()	向数组的开头添加一个或更多元素，并返回新的长度。
valueOf()	返回数组对象的原始值

  //数组去掉重复
  var arr11 = [1,2,2,4,2];
  for(var i=0;i<arr11.length;i++){
    for(var j=i+1;j<arr11.length;j++){
	  if(arr11[i] == arr11[j]){
	    arr11.splice(j,1);
		j--;
	  }
	}
  }
  //alert(arr11);
  
  //排序
  var arr12 = ['c','d','a','e'];
  //arr12.sort();//按字符的编码的高低排序；
 // alert(arr12);
  
  var arr13 = [0,23,2,5,86,32,20,9,66,76];
  //arr13.sort(); //会把数字变成字符串 第一位比较 不支持056
  //alert(arr13);
  //比较函数
  arr13.sort(function(a,b){
    return a - b;
  });
  //alert(arr13)//从小到大排序 b-a 从大到小排序
  
  //快速排序法 希尔，谢尔 冒泡 归并 选择 插入 。。。
  
  var arrwidth = ['345px','23px','10px','1000px'];
  arrwidth.sort(function(a,b){
    return parseInt(a)-parseInt(b);
  }); 
  //alert(arrwidth); //10px 23px 345px 1000px
  
  //随机排序
  var arr14 = [1,2,3,4,5,6,7,8];
  arr14.sort(function(a,b){
    return Math.random()-0.1;
  });
  //alert(arr14);
  
  //随机函数
  //Math.round(Math.random()); 0~1
  //alert(Math.round(Math.random()))
  //alert(Math.round(3.5));  //4舍5入
  //alert(Math.round(Math.random()*10)); //0~10
  //alert(Math.round(Math.random()*5+5));//5~10;
 // alert(Math.round(Math.random()*10+10));//10~20;
  //alert(Math.round(Math.random()*80+20));//20~100
  //x~y Math.round(Math.random()*(y-x)+x));
  
  var x = 42;
  var y = 49;
  //alert(Math.round(Math.random()*(y-x)+x)); //42~49的随机数；
  
  //0~x
  var x1 = 3;
  //alert(Math.round(Math.random()*x1));
  
  //1~x
  var x2 = 3
  //alert(Math.ceil(Math.random()*x2));//ceil 向上取整

5 对象
对象
ECMA-262 把对象（object）定义为“属性的无序集合，每个属性存放一个原始值、对象或函数”。严格来说，这意味着对象是无特定顺序的值的数组。
类
每个对象都由类定义，可以把类看做对象的配方。类不仅要定义对象的接口（interface）（开发者访问的属性和方法），还要定义对象的内部工作
（使属性和方法发挥作用的代码）。编译器和解释程序都根据类的说明构建对象。

创建 JavaScript 对象
通过 JavaScript，您能够定义并创建自己的对象。
创建新对象有两种不同的方法：
定义并创建对象的实例
使用函数来定义对象，然后创建新的对象实例

JavaScript 类
JavaScript 是面向对象的语言，但 JavaScript 不使用类。
在 JavaScript 中，不会创建类，也不会通过类来创建对象（就像在其他面向对象的语言中那样）。
JavaScript 基于 prototype，而不是基于类的。
JavaScript for...in 循环
JavaScript for...in 语句循环遍历对象的属性。

ECMAScript 只有公用作用域
对 ECMAScript 讨论上面这些作用域几乎毫无意义，因为 ECMAScript 中只存在一种作用域 - 公用作用域。ECMAScript 中的所有对象的所有属性和
方法都是公用的。因此，定义自己的类和对象时，必须格外小心。记住，所有属性和方法默认都是公用的！
静态作用域
静态作用域定义的属性和方法任何时候都能从同一位置访问。在 Java 中，类可具有属性和方法，无需实例化该类的对象，即可访问这些属性和方法，例如 
java.net.URLEncoder 类，它的函数 encode() 就是静态方法

ECMAScript 没有静态作用域
严格来说，ECMAScript 并没有静态作用域。不过，它可以给构造函数提供属性和方法。还记得吗，构造函数只是函数。函数是对象，对象可以有属性和方法。例如：
function sayHello() {
  alert("hello");
}

sayHello.alternate = function() {
  alert("hi");
}

sayHello();		//输出 "hello"
sayHello.alternate();	//输出 "hi"

关键字 this
this 的功能
在 ECMAScript 中，要掌握的最重要的概念之一是关键字 this 的用法，它用在对象的方法中。关键字 this 总是指向调用该方法的对象，例如：
var oCar = new Object;
oCar.color = "red";
oCar.showColor = function() {
  alert(this.color);
};

oCar.showColor();		//输出 "red"

使用 this 的原因
为什么使用 this 呢？因为在实例化对象时，总是不能确定开发者会使用什么样的变量名。使用 this，即可在任何多个地方重用同一个函数。请思考下面的例子：
function showColor() {
  alert(this.color);
};

var oCar1 = new Object;
oCar1.color = "red";
oCar1.showColor = showColor;

var oCar2 = new Object;
oCar2.color = "blue";
oCar2.showColor = showColor;

oCar1.showColor();		//输出 "red"
oCar2.showColor();		//输出 "blue"
如果不用对象或 this 关键字引用变量，ECMAScript 就会把它看作局部变量或全局变量。然后该函数将查找名为 color 的局部或全局变量，但是不会找到。结果
如何呢？该函数将在警告中显示 "null"

6 循环，判断和运算符
运算符
JavaScript 算术运算符
算术运算符用于执行变量与/或值之间的算术运算。
给定 y=5，下面的表格解释了这些算术运算符：
运算符	描述	例子	结果
+	加	x=y+2	x=7
-	减	x=y-2	x=3
*	乘	x=y*2	x=10
/	除	x=y/2	x=2.5
%	求余数 (保留整数)	x=y%2	x=1
++	累加	x=++y	x=6
--	递减	x=--y	x=4

JavaScript 赋值运算符
赋值运算符用于给 JavaScript 变量赋值。
给定 x=10 和 y=5，下面的表格解释了赋值运算符：
运算符	例子	等价于	结果
=	x=y	 	x=5
+=	x+=y	x=x+y	x=15
-=	x-=y	x=x-y	x=5
*=	x*=y	x=x*y	x=50
/=	x/=y	x=x/y	x=2
%=	x%=y	x=x%y	x=0

用于字符串的 + 运算符
+ 运算符用于把文本值或字符串变量加起来（连接起来）。
如需把两个或多个字符串变量连接起来，请使用 + 运算符。

       1. for循环，需要知道数组的长度，才能遍历，
　　　　2. forEach循环，循环数组中每一个元素并采取操作， 没有返回值， 可以不用知道数组长度　
　　　　3. map函数，遍历数组每个元素，并回调操作，需要返回值，返回值组成新的数组，原数组不变
　　　　4. filter函数， 过滤通过条件的元素组成一个新数组， 原数组不变　　
　　　　5. some函数，遍历数组中是否有符合条件的元素，返回Boolean值
　　　　6. every函数， 遍历数组中是否每个元素都符合条件， 返回Boolean值
       7 除了遍历数组之外，还有遍历对象，常用方法  for in
　　　　　in 不仅可以用来 遍历对象，还可以用来遍历数组， 不过 i 对应与数组的 key值

利用sort把下面的arr1数组中的对象排序
var arr1 = [
    {name: 'te', value: 5},
    {name: 'te', value: 2},
    {name: 'we', value: 3},
    {name: 'ee', value: 1},
    {name: 'ee', value: 4}
];
 
var by = function(type){
    return function(o,p){
        console.log(o,p);
        var a;
        var b;
        if(typeof o === 'object' && typeof p === 'object' && o && p){
            a = o[type];
            b = p[type];
            if(a === b) {
                return 0;
            }
            if(typeof a === typeof b){
            console.log(a, b);
                return a < b ? -1 : 1
            }
            return typeof a < typeof b ? -1 : 1;
        }else {
            throw('字段有误');
        }
    }
}
console.log(arr1.sort(by('value')));

 后台传过来的数组中，每个对象按 value 排序, value > 5的按顺序排在前面，小于5排在后面
思考后， 可以在原来的的方法中这样写,将数组分成2段，大于等于5和小于5，交换位置即可
var arr1 = [
    {name: 'te', value: 5},
    {name: 'te', value: 2},
    {name: 'we', value: 3},
    {name: 'ee', value: 1},
    {name: 'ee', value: 4}
];
 
var sortObj = function(arr, type , num){
    var by = function(type){
        return function(o,p){
            var a;
            var b;
            if(typeof o === 'object' && typeof p === 'object' && o && p){
                a = o[type];
                b = p[type];
                if(a === b) {
                    return 0;
                }
                if(typeof a === typeof b){
                console.log(a, b);
                    return a < b ? -1 : 1
                }
                return typeof a < typeof b ? -1 : 1;
            }else {
                throw('字段有误');
            }
        }
    };
 
    var cacheArr = arr.sort(by('value'));
 
    //通过num 把数组分成两段
    var arrBf = cacheArr.filter(function(item){
        if(item.value < num){
            return item;
        }
    });
    var arrAf = cacheArr.filter(function(item){
        if(item.value >= num){
            return item;
        }
    });
 
    //交换位置 即可得到
    var newArr = arrAf.concat(arrBf);
    return newArr;
};
console.log(sortObj(arr1, 'value' , 3));

7 定时器

定时器的写法
setInterval(expression,milliseconds)；
setTimeout(expression,milliseconds)；
上式中，expression既可以是字符串，也可以是匿名函数，或者也可以是一个函数名。但是，函数名中不能传参。第二个参数为延迟要执行的时间。
具体写法如下：
（1）函数名，不带参数
setInterval(test,1000)；           //1秒后执行
（2）字符串，可以执行的代码
setInterval('test()',1000)；       //1秒后执行
（3）匿名函数
setInterval(function(){},1000)；   //1秒后执行
（4）调用函数
setInterval(test,1000)；           //立即执行

定时器的写法
setInterval(expression,milliseconds)；
setTimeout(expression,milliseconds)；
上式中，expression既可以是字符串，也可以是匿名函数，或者也可以是一个函数名。但是，函数名中不能传参。第二个参数为延迟要执行的时间。
具体写法如下：
（1）函数名，不带参数
setInterval(test,1000)；           //1秒后执行
（2）字符串，可以执行的代码
setInterval('test()',1000)；       //1秒后执行
（3）匿名函数
setInterval(function(){},1000)；   //1秒后执行
（4）调用函数
setInterval(test,1000)；           //立即执行

如果没有特殊指向，setInterval和setTimeout的回调函数中this的指向都是window。这是因为JS的定时器方法是定义在window下的。但是平时很多场景下，
都需要修改this的指向。这里总结了几种：

1、最常用的方法：在外部函数中将this存为一个变量，回调函数中使用该变量，而不是直接使用this。


 1 var name = 'my name is window';
 2 var obj = {
 3     name: 'my name is obj',
 4     fn: function () {
 5         var that = this;
 6         var timer = null;
 7         clearInterval(timer);
 8         timer = setInterval(function () {
 9             console.log(that.name);   //my name is obj
10         }, 1000)
11     }
12 }

在fn中加了var that = this; 回调函数中使用that代替this即可。这种方法最常见，使用也最广泛。

2、使用bind()方法（bind()为ES5的标准，低版本IE下有兼容问题，可以引入es5-shim.js解决）

bind()的作用类似call和apply，都是修改this指向。但是call和apply是修改this指向后函数会立即执行，而bind则是返回一个新的函数，它会创建一个与原
来函数主体相同的新函数，新函数中的this指向传入的对象。


 1 var name = 'my name is window';
 2 var obj = {
 3     name: 'my name is obj',
 4     fn: function () {
 5         var timer = null;
 6         clearInterval(timer);
 7         timer = setInterval(function () {
 8             console.log(this.name);   //my name is obj
 9         }.bind(this), 1000)
10     }
11 }

在这里为什么不能用call和apply，是因为call和apply不是返回函数，而是立即执行函数，那么，就失去了定时器的作用。

3、使用es6的箭头函数：箭头函数的最大作用就是this指向。


 1 var name = 'my name is window';
 2 var obj = {
 3     name: 'my name is obj',
 4     fn: function () {
 5         var timer = null;
 6         clearInterval(timer);
 7         timer = setInterval(() => {
 8             console.log(this.name);  //my name is obj
 9         }, 1000)
10     }
11 }

requestAnimationFrame 比起 setTimeout、setInterval的优势主要有两点：
1、requestAnimationFrame 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，
一般来说，这个频率为每秒60帧。
2、在隐藏或不可见的元素中，requestAnimationFrame将不会进行重绘或回流，这当然就意味着更少的的cpu，gpu和内存使用量。
cancelAnimationFrame函数来取消requestAnimationFrame的回调

8 函数 及 作用域

JavaScript 函数语法
函数就是包裹在花括号中的代码块，前面使用了关键词 function：
function functionname()
{
这里是要执行的代码
}
当调用该函数时，会执行函数内的代码。
可以在某事件发生时直接调用函数（比如当用户点击按钮时），并且可由 JavaScript 在任何位置进行调用。
提示：JavaScript 对大小写敏感。关键词 function 必须是小写的，并且必须以与函数名称相同的大小写来调用函数。
调用带参数的函数
在调用函数时，您可以向其传递值，这些值被称为参数。
这些参数可以在函数中使用。
您可以发送任意多的参数，由逗号 (,) 分隔：
myFunction(argument1,argument2)
当您声明函数时，请把参数作为变量来声明：
function myFunction(var1,var2)
{
这里是要执行的代码
}
变量和参数必须以一致的顺序出现。第一个变量就是第一个被传递的参数的给定的值，以此类推。
实例
<button onclick="myFunction('Bill Gates','CEO')">点击这里</button>

<script>
function myFunction(name,job)
{
alert("Welcome " + name + ", the " + job);
}
</script>

带有返回值的函数
有时，我们会希望函数将值返回调用它的地方。
通过使用 return 语句就可以实现。
在使用 return 语句时，函数会停止执行，并返回指定的值。
语法
function myFunction()
{
var x=5;
return x;
}
上面的函数会返回值 5。
注释：整个 JavaScript 并不会停止执行，仅仅是函数。JavaScript 将继续执行代码，从调用函数的地方。
函数调用将被返回值取代：
var myVar=myFunction();
myVar 变量的值是 5，也就是函数 "myFunction()" 所返回的值。
即使不把它保存为变量，您也可以使用返回值：
document.getElementById("demo").innerHTML=myFunction();
"demo" 元素的 innerHTML 将成为 5，也就是函数 "myFunction()" 所返回的值。
您可以使返回值基于传递到函数中的参数：
实例
计算两个数字的乘积，并返回结果：
function myFunction(a,b)
{
return a*b;
}

document.getElementById("demo").innerHTML=myFunction(4,3);
"demo" 元素的 innerHTML 将是：
12
亲自试一试
在您仅仅希望退出函数时 ，也可使用 return 语句。返回值是可选的：
function myFunction(a,b)
{
if (a>b)
  {
  return;
  }
x=a+b
}
如果 a 大于 b，则上面的代码将退出函数，并不会计算 a 和 b 的总和。
局部 JavaScript 变量
在 JavaScript 函数内部声明的变量（使用 var）是局部变量，所以只能在函数内部访问它。（该变量的作用域是局部的）。
您可以在不同的函数中使用名称相同的局部变量，因为只有声明过该变量的函数才能识别出该变量。
只要函数运行完毕，本地变量就会被删除。
全局 JavaScript 变量
在函数外声明的变量是全局变量，网页上的所有脚本和函数都能访问它。
JavaScript 变量的生存期
JavaScript 变量的生命期从它们被声明的时间开始。
局部变量会在函数运行以后被删除。
全局变量会在页面关闭后被删除。
向未声明的 JavaScript 变量来分配值
如果您把值赋给尚未声明的变量，该变量将被自动作为全局变量声明。
这条语句：
carname="Volvo";
将声明一个全局变量 carname，即使它在函数内执行。

1.函数声明

function sum1(n1,n2){
    return n1+n2;
  };
2.函数表达式，又叫函数字面量

var sum2=function(n1,n2){
    return n1+n2;
};
两者的区别：解析器会先读取函数声明，并使其在执行任何代码之前可以访问；而函数表达式则必须等到解析器执行到它所在的代码行才会真正被解释执行。
自执行函数严格来说也叫函数表达式，它主要用于创建一个新的作用域，在此作用域内声明的变量，不会和其它作用域内的变量冲突或混淆，大多是以匿名函
数方式存在，且立即自动执行。

(function(n1,n2){
    console.log (n1+n2)
})(1,3);//4

另外几种自执行函数：
//可用来传参
(function(x,y){
  console.log(x+y);
})(2,3);
 
//带返回值
var sum=(function(x,y){
  return x+y;
})(2,3);
console.log(sum);
 
~function(){
  var name='~'
  console.log(name);
}();
 
!function(){
  var name='!'
  console.log(name);
}();
 
;(function(){
  var name=';'
  console.log(name);
})();
 
-function(){
  var name='-'
  console.log(name);
}();
 
//逗号运算符
1,function(){
  var name=',';
  console.log(name);
}();
 
//异或
1^function(){
  var name='^';
  console.log(name);
}();
 
//比较运算符
1>function(){
  var name='>';
  console.log(name);
}();
 
~+-!(function(){
  var name='~+-!';
  console.log(name);
})();
 
~!(function(){
  var name='~!';
  console.log(name);
})();
 
(function(){
  var name='call';
  console.log(name);
}).call();
 
(function(){
  var name='apply';
  console.log(name);
}).apply();

3.函数构造法，参数必须加引号


var sum3=new Function('n1','n2','return n1+n2');
console.log(sum3(2,3));//5
从技术角度讲，这是一个函数表达式。一般不推荐用这种方法定义函数，因为这种语法会导致解析两次代码（第一次是解析常规ECMAScript代码，第二次是解析
传入构造函数中的字符串），从而影响性能。

var name='haoxl';
  function fun(){
    var name='lili';
    return new Function('return name');//不能获取局部变量
  }
 console.log(fun()());//haoxl
 Function()构造函数每次执行时都会解析函数主体，并创建一个新的函数对象，所以当在一个循环或频繁执行的函数中调用Function()构造函数效率是非常低的。
 而函数字面量却不是每次遇到都会重新编译的，用Function()构造函数创建一个函数时并不遵循典型的作用域，它一直把它当作是顶级函数来执行。
 
 4 作为函数方法调用函数：(这种可以设置this的值，我可以返回不同this！)
   在js中函数是对象，是对象就有属性个方法，而call（）和apply（）是预定义的函数方法！
   这两个方法都可以调用函数，两个方法的第一个参数必须是对象的本身！
   
如果想要对函数有更深刻的理解，或者正确认识函数！需要我们先做一件事，那就是了解js的运行机制问题：
        1、在js中js引擎会优先解析var变量和function定义！在预解析完成后从上到下逐步进行！
        2、解析var变量时，会把值存储在“执行环境”中，而不会去赋值，值是存储作用！例如:
        alert（a）;  var a = 5;  这时会输出undifiend,意思是没有被初始化没有被赋值!
        这并不是没有被定义，错误了的意思！
        3、在解析function时会把函数整体定义，这也就解释了为什么在function定义函数时为什么可以先调用后声明了！其实表面上看是先调用了，其实在内部机
	制中第一步实行的是把以function方式定义的函数先声明了！

javascrit中函数有一个内置的对象arguments对象！
      作用是：1.在js中函数定义没有任何参数，调用该函数时可以传递任意参数！
      2.arguments对象是数组对象。
      3.arguments对象的length属性：获取函数的实参个数！
      4.利用Arguments对象特性,实现模拟函数的重载的效果.
	

9 面向对象

一、理解对象:

         第一种：基于Object对象

var person = new Object();
person.name = 'My Name';
person.age = 18;
person.getName = function(){
    return this.name;
}
        第二种：对象字面量方式（比较清楚的查找对象包含的属性及方法）

var person = {
    name : 'My name',
    age : 18,
    getName : function(){
        return this.name;
    }
}
      JS的对象可以使用‘.’操作符动态的扩展其属性，可以使用’delete’操作符或将属性值设置为’undefined’来删除属性。如下：

person.newAtt=’new Attr’;//添加属性
alert(person.newAtt);//new Attr
delete person.age;
alert(person.age);//undefined(删除属性后值为undefined);

二、对象属性类型

      ECMA-262第5版定义了JS对象属性中特征（用于JS引擎，外部无法直接访问）。ECMAScript中有两种属性：数据属性和访问器属性

      1、数据属性：

      数据属性指包含一个数据值的位置，可在该位置读取或写入值，该属性有4个供述其行为的特性：

      [[configurable]]:表示能否使用delete操作符删除从而重新定义，或能否修改为访问器属性。默认为true;

      [[Enumberable]]:表示是否可通过for-in循环返回属性。默认true;

      [[Writable]]:表示是否可修改属性的值。默认true;

      [[Value]]:包含该属性的数据值。读取/写入都是该值。默认为undefined;如上面实例对象person中定义了name属性，其值为’My name’,对该值的修改
      都反正在这个位置

      要修改对象属性的默认特征（默认都为true)，可调用Object.defineProperty()方法，它接收三个参数：属性所在对象，属性名和一个描述符对象
      （必须是：configurable、enumberable、writable和value，可设置一个或多个值）。

      如下：（浏览器支持：IE9+、Firefox 4+、Chrome、Safari5+）

var person = {};
Object.defineProperty(person, 'name', {
    configurable: false,
    writable: false,
    value: 'Jack'
});
alert(person.name);//Jack
delete person.name;
person.name = 'lily';
alert(person.name);//Jack
      可以看出，delete及重置person.name的值都没有生效，这就是因为调用defineProperty函数修改了对象属性的特征；值得注意的是一旦将
      configurable设置为false，则无法再使用defineProperty将其修改为true（执行会报错：can't redefine non-configurable property）;

      2、访问器属性：

      它主要包括一对getter和setter函数，在读取访问器属性时，会调用getter返回有效值；写入访问器属性时，调用setter，写入新值；该属性有
      以下4个特征：

      [[Configurable]]:是否可通过delete操作符删除重新定义属性；

      [[Numberable]]:是否可通过for-in循环查找该属性；

      [[Get]]:读取属性时调用，默认：undefined;

      [[Set]]:写入属性时调用，默认：undefined;

      访问器属性不能直接定义，必须使用defineProperty()来定义，如下：

var person = {
    _age: 18
};
Object.defineProperty(person, 'isAdult', {
    get: function () {
        if (this._age >= 18) {
            return true;
        } else {
            return false;
        }
    }
});
alert(person.isAdult?'成年':'未成年');//成年
      从上面可知，定义访问器属性时getter与setter函数不是必须的,并且，在定义getter与setter时不能指定属性的configurable及writable特性；

      此外，ECMA-262（5）还提供了一个Object.defineProperties()方法，可以用来一次性定义多个属性的特性：

var person = {};
Object.defineProperties(person,{
    _age:{
        value:19
    },
    isAdult:{
        get: function () {
            if (this._age >= 18) {
                return true;
            } else {
                return false;
            }
        }
    }
});
alert(person.isAdult?'成年':'未成年');//成年
 

      上述代码使用Object.defineProperties()方法同时定义了_age及isAudlt两个属性的特性

      此外，使用Object.getOwnPropertyDescriptor()方法可以取得给定属性的特性：

var descriptor = Object.getOwnPropertyDescriptor(person,'_age');
alert(descriptor.value);//19
   对于数据属性，可以取得：configurable,enumberable,writable和value；

   对于访问器属性，可以取得：configurable,enumberable,get和set

三、创建对象

使用Object构造函数或对象字面量都可以创建对象，但缺点是创建多个对象时，会产生大量的重复代码，因此下面介绍可解决这个问题的创建对象的方法

     1、工厂模式

function createPerson(name, age, job) {
    var o = new Object();
    o.name = name;
    o.age = age;
    o.job = job;
    o.getName = function () {
        return this.name;
    }
    return o;//使用return返回生成的对象实例
}
var person = createPerson('Jack', 19, 'SoftWare Engineer');
     创建对象交给一个工厂方法来实现，可以传递参数，但主要缺点是无法识别对象类型，因为创建对象都是使用Object的原生构造函数来完成的。

     2、构造函数模式

function Person(name,age,job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.getName = function () {
        return this.name;
    }
}
var person1 = new Person('Jack', 19, 'SoftWare Engineer');

var person2 = new Person('Liye', 23, 'Mechanical Engineer');

 

     使用自定义的构造函数（与普通函数一样，只是用它来创建对象），定义对象类型（如：Person）的属性和方法。它与工厂方法区别在于：

没有显式地创建对象
直接将属性和方法赋值给this对象；
没有return语句；
      此外，要创建Person的实例，必须使用new关键字，以Person函数为构造函数，传递参数完成对象创建；实际创建经过以下4个过程：

创建一个对象
将函数的作用域赋给新对象（因此this指向这个新对象，如：person1）
执行构造函数的代码
返回该对象
     上述由Person构造函数生成的两个对象person1与person2都是Person的实例，因此可以使用instanceof判断，并且因为所有对象都继承Object，
     因此person1 instanceof Object也返回真：

alert(person1 instanceof Person);//true;
alert(person2 instanceof Person);//true;
alert(person1 instanceof Object);//true;
alert(person1.constructor === person2.constructor);//ture;
     虽然构造函数方式比较不错，但也存在缺点，那就是在创建对象时，特别针对对象的属性指向函数时，会重复的创建函数实例，以上述代码为基础，
     可以改写为：

function Person(name,age,job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.getName = new Function () {//改写后效果与原代码相同，不过是为了方便理解
        return this.name;
    }
}
   上述代码，创建多个实例时，会重复调用new Function();创建多个函数实例，这些函数实例还不是一个作用域中，当然这一般不会有错，但这会造成
   内存浪费。当然，可以在函数中定义一个getName = getName的引用，而getName函数在Person外定义，这样可以解决重复创建函数实例问题，但在效
   果上并没有起到封装的效果，如下所示：
function Person(name,age,job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.getName = getName;
}
function getName() {//到处是代码，看着乱！！
        return this.name;
}
     3、原型模式

     JS每个函数都有一个prototype(原型)属性，这个属性是一个指针，指向一个对象，它是所有通过new操作符使用函数创建的实例的原型对象。原型对象
     最大特点是，所有对象实例共享它所包含的属性和方法，也就是说，所有在原型对象中创建的属性或方法都直接被所有对象实例共享。

function Person(){
}
Person.prototype.name = 'Jack';//使用原型来添加属性
Person.prototype.age = 29;
Person.prototype.getName = function(){
    return this.name;
}
var person1 = new Person();
alert(person1.getName());//Jack
var person2 = new Person();
alert(person1.getName === person2.getName);//true;共享一个原型对象的方法
      原型是指向原型对象的，这个原型对象与构造函数没有太大关系，唯一的关系是函数的prototype是指向这个原型对象！而基于构造函数创建的对象实例
      也包含一个内部指针为：[[prototype]]指向原型对象。

       实例属性或方法的访问过程是一次搜索过程：

首先从对象实例本身开始，如果找到属性就直接返回该属性值；
如果实例本身不存在要查找属性，就继续搜索指针指向的原型对象，在其中查找给定名字的属性，如果有就返回；
     基于以上分析，原型模式创建的对象实例，其属性是共享原型对象的；但也可以自己实例中再进行定义，在查找时，就不从原型对象获取，而是根据搜索
     原则，得到本实例的返回；简单来说，就是实例中属性会屏蔽原型对象中的属性；

     原型与in操作符

     一句话：无论原型中属性，还是对象实例的属性，都可以使用in操作符访问到；要想判断是否是实例本身的属性可以使用
     object.hasOwnProperty(‘attr’)来判断；

     原生对象中原型

     原生对象中原型与普通对象的原型一样，可以添加/修改属性或方法，如以下代码为所有字符串对象添加去左右空白原型方法：

String.prototype.trim = function(){
    return this.replace(/^\s+/,'').replace(/\s+$/,'');
}
var str = '   word space   ';
alert('!'+str.trim()+'!');//!word space!
     原型模式的缺点，它省略了为构造函数传递初始化参数，这在一定程序带来不便；另外，最主要是当对象的属性是引用类型时，它的值是不变的，总是
     引用同一个外部对象，所有实例对该对象的操作都会其它实例：

function Person() {
}
Person.prototype.name = 'Jack';
Person.prototype.lessons = ['Math','Physics'];
var person1 = new Person();
person1.lessons.push('Biology');
var person2 = new Person();
alert(person2.lessons);//Math,Physics,Biology，person1修改影响了person2
     4、组合构造函数及原型模式

      目前最为常用的定义类型方式，是组合构造函数模式与原型模式。构造函数模式用于定义实例的属性，而原型模式用于定义方法和共享的属性。结果，
      每个实例都会有自己的一份实例属性的副本，但同时又共享着对方方法的引用，最大限度的节约内存。此外，组合模式还支持向构造函数传递参数，
      可谓是集两家之所长。

function Person(name, age, job) {
    this.name = name;
    this.age = age;
    this.job = job;
    this.lessons = ['Math', 'Physics'];
}
Person.prototype = {
    constructor: Person,//原型字面量方式会将对象的constructor变为Object，此外强制指回Person
    getName: function () {
        return this.name;
    }
}
var person1 = new Person('Jack', 19, 'SoftWare Engneer');
person1.lessons.push('Biology');
var person2 = new Person('Lily', 39, 'Mechanical Engneer');
alert(person1.lessons);//Math,Physics,Biology
alert(person2.lessons);//Math,Physics
alert(person1.getName === person2.getName);//true,//共享原型中定义方法
 

   在所接触的JS库中，jQuery类型的封装就是使用组合模式来实例的！！！

 
    5、动态原型模式

     组合模式中实例属性与共享方法（由原型定义）是分离的，这与纯面向对象语言不太一致；动态原型模式将所有构造信息都封装在构造函数中，又保持
     了组合的优点。其原理就是通过判断构造函数的原型中是否已经定义了共享的方法或属性，如果没有则定义，否则不再执行定义过程。该方式只原型上
     方法或属性只定义一次，且将所有构造过程都封装在构造函数中，对原型所做的修改能立即体现所有实例中：

function Person(name, age, job) {
    this.name = name;
    this.age = age;
    this.job = job;
    this.lessons = ['Math', 'Physics'];
}
if (typeof this.getName != 'function') {//通过判断实例封装
　　Person.prototype = {
　　　　constructor: Person,//原型字面量方式会将对象的constructor变为Object，此外强制指回Person
　　　　getName: function () {
　　　　　　return this.name;
　　　　}
　　}
}
var person1 = new Person('Jack', 19, 'SoftWare Engneer');
person1.lessons.push('Biology');
var person2 = new Person('Lily', 39, 'Mechanical Engneer');
alert(person1.lessons);//Math,Physics,Biology
alert(person2.lessons);//Math,Physics
alert(person1.getName === person2.getName);//true,//共享原型中定义方法

闭包 

一、变量的作用域
要理解闭包，首先必须理解Javascript特殊的变量作用域。
变量的作用域无非就是两种：全局变量和局部变量。
Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。

Js代码
　　var n=999;
　　function f1(){
　　　　alert(n);
　　}
　　f1(); // 999
另一方面，在函数外部自然无法读取函数内的局部变量。
Js代码
　　function f1(){
　　　　var n=999;
　　}
　　alert(n); // error
这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！
Js代码
　　function f1(){
　　　　n=999;
　　}
　　f1();
　　alert(n); // 999

二、如何从外部读取局部变量？
出于种种原因，我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。
那就是在函数的内部，再定义一个函数。
Js代码
　　function f1(){
　　　　n=999;
　　　　function f2(){
　　　　　　alert(n); // 999
　　　　}
　　}
在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1 就是不可
见的。这就是Javascript语言特有的“链式作用域”结构（chain scope），
子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。
既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！

Js代码
　　function f1(){
　　　　n=999;
　　　　function f2(){
　　　　　　alert(n);
　　　　}
　　　　return f2;
　　}
　　var result=f1();
　　result(); // 999

三、闭包的概念
上一节代码中的f2函数，就是闭包。
各种专业文献上的“闭包”（closure）定义非常抽象，很难看懂。我的理解是，闭包就是能够读取其他函数内部变量的函数。
由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。
所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。
--------------------------------------------------------------------------------------------------------b
四、闭包的用途
闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。
怎么来理解这句话呢？请看下面的代码。

Js代码
　　function f1(){
　　　　var n=999;
　　　　nAdd=function(){n+=1}
　　　　function f2(){
　　　　　　alert(n);
　　　　}
　　　　return f2;
　　}
　　var result=f1();
　　result(); // 999
　　nAdd();
　　result(); // 1000
在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内
存中，并没有在f1调用后被自动清除。
为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在
调用结束后，被垃圾回收机制（garbage collection）回收。
这段代码中另一个值得注意的地方，就是“nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此 nAdd是一个全局变量，而不是局部变
量。其次，nAdd的值是一个匿名函数（anonymous function），而这个
匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。

五、使用闭包的注意点
1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，
在退出函数之前，将不使用的局部变量全部删除。
2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部
变量当作它的私有属性（private value），这时一定要小心，不要随便
改变父函数内部变量的值。

六、思考题
如果你能理解下面代码的运行结果，应该就算理解闭包的运行机制了。
Js代码 
　　var name = "The Window";   
　　var object = {   
　　　　name : "My Object",   
　　　　getNameFunc : function(){   
　　　　　　return function(){   
　　　　　　　　return this.name;   
　　　　　};   
　　　　}   
};   
alert(object.getNameFunc()());  //The Window

JavaScript闭包例子
function outerFun()
 {
  var a=0;
  function innerFun()
  {
   a++;
   alert(a);
  }    
 }
innerFun()
上面的代码是错误的.innerFun()的作用域在outerFun()内部,所在outerFun()外部调用它是错误的.
改成如下,也就是闭包:
Js代码
function outerFun()
{
 var a=0;
 function innerFun()
 {
  a++;
  alert(a);
 }
 return innerFun;  //注意这里
}
var obj=outerFun();
obj();  //结果为1
obj();  //结果为2
var obj2=outerFun();
obj2();  //结果为1
obj2();  //结果为2
什么是闭包:
当内部函数 在定义它的作用域 的外部 被引用时,就创建了该内部函数的闭包 ,如果内部函数引用了位于外部函数的变量,当外部函数调用完毕后,这些
变量在内存不会被 释放,因为闭包需要它们.

再来看一个例子
Js代码
function outerFun()
{
 var a =0;
 alert(a);  
}
var a=4;
outerFun();
alert(a);
结果是 0,4 .  因为在函数内部使用了var关键字 维护a的作用域在outFun()内部.
再看下面的代码:
Js代码 

function outerFun()
{
 //没有var 
 a =0;
 alert(a);  
}
var a=4;
outerFun();
alert(a);
结果为 0,0 真是奇怪,为什么呢?
作用域链是描述一种路径的术语,沿着该路径可以确定变量的值 .当执行a=0时,因为没有使用var关键字,因此赋值操作会沿着作用域链到var a=4;  
并改变其值.

如果你对javascript闭包还不是很理解，那么请看下面转载的文章：(转载:http://www.felixwoo.com/archives/247)

一、什么是闭包？
官方”的解释是：闭包是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。
相信很少有人能直接看懂这句话，因为他描述的太学术。其实这句话通俗的来说就是：JavaScript中所有的function都是一个闭包。不过一般来说，嵌套
的function所产生的闭包更为强大，也是大部分时候我们所谓的“闭包”。看下面这段代码：
function a() { 
 var i = 0; 
 function b() { alert(++i); } 
 return b;
}
var c = a();
c();
这段代码有两个特点：
1、函数b嵌套在函数a内部；
2、函数a返回函数b。
引用关系如图：

　　这样在执行完var c=a()后，变量c实际上是指向了函数b，再执行c()后就会弹出一个窗口显示i的值(第一次为1)。这段代码其实就创建了一个闭包，为
  什么？因为函数a外的变量c引用了函数a内的函数b，就是说：
　　当函数a的内部函数b被函数a外的一个变量引用的时候，就创建了一个闭包。
　　让我们说的更透彻一些。所谓“闭包”，就是在构造函数体内定义另外的函数作为目标对象的方法函数，而这个对象的方法函数反过来引用外层函数体中的临
  时变量。这使得只要目标 对象在生存期内始终能保持其方法，就能间接保持原构造函数体当时用到的临时变量值。尽管最开始的构造函数调用已经结束，临时
  变量的名称也都消失了，但在目 标对象的方法内却始终能引用到该变量的值，而且该值只能通这种方法来访问。即使再次调用相同的构造函数，但只会生成新
  对象和方法，新的临时变量只是对应新 的值，和上次那次调用的是各自独立的。
二、闭包有什么作用？
　　简而言之，闭包的作用就是在a执行完并返回后，闭包使得Javascript的垃圾回收机制GC不会收回a所占用的资源，因为a的内部函数b的执行需要依赖a中的
  变量。这是对闭包作用的非常直白的描述，不专业也不严谨，但大概意思就是这样，理解闭包需要循序渐进的过程。
在上面的例子中，由于闭包的存在使得函数a返回后，a中的i始终存在，这样每次执行c()，i都是自加1后alert出i的值。
　　那 么我们来想象另一种情况，如果a返回的不是函数b，情况就完全不同了。因为a执行完后，b没有被返回给a的外界，只是被a所引用，而此时a也只会被b引 
  用，因此函数a和b互相引用但又不被外界打扰(被外界引用)，函数a和b就会被GC回收。(关于Javascript的垃圾回收机制将在后面详细介绍)
三、闭包内的微观世界
　　如果要更加深入的了解闭包以及函数a和嵌套函数b的关系，我们需要引入另外几个概念：函数的执行环境(excution context)、活动对象(call object)、
  作用域(scope)、作用域链(scope chain)。以函数a从定义到执行的过程为例阐述这几个概念。
当定义函数a的时候，js解释器会将函数a的作用域链(scope chain)设置为定义a时a所在的“环境”，如果a是一个全局函数，则scope chain中只有window对象。
当执行函数a的时候，a会进入相应的执行环境(excution context)。
在创建执行环境的过程中，首先会为a添加一个scope属性，即a的作用域，其值就为第1步中的scope chain。即a.scope=a的作用域链。
然后执行环境会创建一个活动对象(call object)。活动对象也是一个拥有属性的对象，但它不具有原型而且不能通过JavaScript代码直接访问。创建完活动对
象后，把活动对象添加到a的作用域链的最顶端。此时a的作用域链包含了两个对象：a的活动对象和window对象。
下一步是在活动对象上添加一个arguments属性，它保存着调用函数a时所传递的参数。
最后把所有函数a的形参和内部的函数b的引用也添加到a的活动对象上。在这一步中，完成了函数b的的定义，因此如同第3步，函数b的作用域链被设置为b所被定
义的环境，即a的作用域。
到此，整个函数a从定义到执行的步骤就完成了。此时a返回函数b的引用给c，又函数b的作用域链包含了对函数a的活动对象的引用，也就是说b可以访问到a中定
义的所有变量和函数。函数b被c引用，函数b又依赖函数a，因此函数a在返回后不会被GC回收。
当函数b执行的时候亦会像以上步骤一样。因此，执行时b的作用域链包含了3个对象：b的活动对象、a的活动对象和window对象，如下图所示：

如图所示，当在函数b中访问一个变量的时候，搜索顺序是：
先搜索自身的活动对象，如果存在则返回，如果不存在将继续搜索函数a的活动对象，依次查找，直到找到为止。
如果函数b存在prototype原型对象，则在查找完自身的活动对象后先查找自身的原型对象，再继续查找。这就是Javascript中的变量查找机制。
如果整个作用域链上都无法找到，则返回undefined。
小结，本段中提到了两个重要的词语：函数的定义与执行。文中提到函数的作用域是在定义函数时候就已经确定，而不是在执行的时候确定（参看步骤1和3）。
用一段代码来说明这个问题：
function f(x) { 
  var g = function () { return x; }
  return g;
}
var h = f(1);
alert(h()); 
这段代码中变量h指向了f中的那个匿名函数(由g返回)。
假设函数h的作用域是在执行alert(h())确定的，那么此时h的作用域链是：h的活动对象->alert的活动对象->window对象。
假设函数h的作用域是在定义时确定的，就是说h指向的那个匿名函数在定义的时候就已经确定了作用域。那么在执行的时候，h的作用域链为：h的活动对象
->f的活动对象->window对象。
如果第一种假设成立，那输出值就是undefined；如果第二种假设成立，输出值则为1。
运行结果证明了第2个假设是正确的，说明函数的作用域确实是在定义这个函数的时候就已经确定了。

四、闭包的应用场景
保护函数内的变量安全。以最开始的例子为例，函数a中i只有函数b才能访问，而无法通过其他途径访问到，因此保护了i的安全性。
在内存中维持一个变量。依然如前例，由于闭包，函数a中i的一直存在于内存中，因此每次执行c()，都会给i自加1。
通过保护变量的安全实现JS私有属性和私有方法（不能被外部访问）
私有属性和方法在Constructor外是无法被访问的
function Constructor(...) {  
  var that = this;  
  var membername = value; 
  function membername(...) {...}
}
以上3点是闭包最基本的应用场景，很多经典案例都源于此。

五、Javascript的垃圾回收机制
在Javascript中，如果一个对象不再被引用，那么这个对象就会被GC回收。如果两个对象互相引用，而不再被第3者所引用，那么这两个互相引用的对象也
会被回收。因为函数a被b引用，b又被a外的c引用，这就是为什么函数a执行后不会被回收的原因。

JS的函数递归，主要从“变量+函数”和“函数+变量”两个方面说明解释。 

相对简单，直接上代码。

一、知识说明

function fun()
{
    // 自己调用自己，称为递归调用
    fun();
    console.log("m2");
}
fun();

二、函数+变量

// 用递归 来求 5 的阶乘
// n! = n * (n-1)!

// 定义一个函数，用于求 n 的阶乘
function func(n)
{
    if (n == 1)
    {
        return 1;
    }

    // func(n-1) 因为传递的参数是 n-1,那么就是求 (n-1) 的阶乘
    return n * func(n-1);
}
console.log(     func(5)   );

三、函数+函数

//斐波拉契题(兔子生兔子题目)--从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔
子对数为多少
// 产量分析：1， 1， 2， 3， 5， 8， 13， 21 。。。
// 第n个月的兔子总数  =  第n-1个月的兔子总数 + 第n-2个月的兔子总数
// 问题： 求任意月兔子的总数

function func( n )
{
    if (n == 0 || n == 1)
    {
        return 1;
    }
    return func(n-1) + func(n-2);
}

var a = func(22);


