
    正则表达式
	  字符串操作
	    indexOf   查找
		substring  获取字符串
		charAt  获取某个字符串
		split  分割字符串，获得数组
	正则：也叫规则  让计算机能够读懂人类的规则
	正则都是操作字符串的
	
	var re = /a/;
	var re = new RegExp('a');
	
	test : 正则去匹配字符串，如果匹配成功就返回真，如果匹配失败就返回假
	  字符串判断
	    返回真假
		正则.test(字符串)
	
		
	search :正则去匹配字符串，如果匹配成功，就返回匹配成功的位置，如果匹配失败就返回-1
	  字符串搜索
	    返回出现的位置
		字符串.search（正则）
		默认区分大小写；
		如果不区分大小的话，在正则的最后加标识 i 
		忽略大小写： i------ignore
		
   macth:正则去匹配字符串，如果匹配成功，就返回匹配成功额数组，如果匹配不成功，就返回null。
     获取匹配的项目
	   返回数组
	   量词：+
	   全局匹配：g---global
	   字符串.macth(正则)
		
	replace
	  替换所有匹配
	    返回替换后的字符串
		字符串.replace（正则，想替换的）
		
	
  */
  
  var  str = 'jfjf646dafry5uyt4yt6k3j31dt6463';
  
  function findnum(str){
    return str.match(/\d+/g);
  }
  //alert(findnum(str));
  
 // var str1 = 'abcdef';
  //var re1 = /b/;
 // var re1 = /bc/; //true
 // var re1 = /bd/; //false;
  //alert(re1.test(str1));  //ttrue
  
  //转义字符 \n \r  \t
  /*
    \s:空格
	\S:非空格
	\d:数字
	\D:非数字
	\w:字符  （字母  ，数字，下划线）
	\W:非字符
  */
   
  var str1 = '34343213t54486';
  
  var re = /\D/;
  
  if(re.test(str)){
    //alert('不全是数字')
  }else{
    //alert('全是数字');
  }
  
  var str2 = 'abcdef'
  
  var re2 = /b/;
  var re2 = new RegExp('B','i');
 // alert(str.search(re2));
 
 
 //正则默认：正则匹配成功就会结束，不会继续匹配  , 如果想全部查找，就要加标识 g（全局匹配）
 //量词  匹配不确定的位置  + 至少出现一次
 var str3 = 'jfjf646dafry5uyt4yt6k3j31dt6463';
 
 var re3 = /\d+/g ;
 
 //alert(str3.match(re3));
 
 
 //replace：正则去匹配字符串，匹配成功的字符去替换新的字符串
 //写法  字符串.replace(正则，新的字符串)
 
 var str4 = 'aaa';
 var re4 = /a/;
 str4 = str.replace(re4,'b');
 
 /*
  正则表达式字符类
    任意字符
	  [abc]  整体代表一个字符
	     例  o[usb]t--obt,ost,out
	范围  代表多位：+
	  [a-z],[0-9]
	    例子 ： id[0-9]--id0,id5
	排除  如果……写在[]里面的话 就是排除的意思
	  [^a]
	    例  o[^0-9]t--oat,o?t ,ot
 */
 var str = 'abc';
 var re = //;
 
 /*
   转义字符
    . (点) ：任意字符   真正的点 \.
	\b :独立的部分   起始  结束  空格
	\B：非独立的部分
	\1 重复子项
	
 */
 
 var str = 'onetwo';
 
 var re = /\bone/;
 
 //alert(re.test(str));  //true;
 
 /*
  量词 ：{}
   {4，7} 最少出现4次  最多出现7次
   {4，} 最少4次
   {4} 正好4次
   
   + : {1,}  \d{1,}
   ? : {0,1}  出现0次 或者1次
   * : {0}  至少出现0次
   
 */
 
 var str = 'abc';
 var re = /ab*/;
 
 //alert(re.text(str));
 
 /*
   高级表单验证
    匹配中文  [\u4e00-\u9fa5]
	行首行尾  ^s*|\s*$
	Email :  ^\w+@[a-z0-9]+(\.[a-z]+){1,3}$
	网址     [a-zA-Z]+://[^\s]*
	qq号     [1-9][0-9]{4,9}  /^[1-9]\d{4,11}$/
	邮政编码  [1-9]\d{5}
	身份证    [1-9]\d{14}|[1-9]\d{17}|[1-9]\d{16}x 
 */
 
 /*
  正则与面向对象
    把方法包在一个空间里
	   有人管他叫--命名空间
	   在公司里，把同一类方法，包在一起
	   JSON的使用
	   把之前的方法，包在一起
 */
  
  
  匹配class
    function getclsss(obj,oclass){
	    var arr = [];
	    var aele = obj.getElementsByTagName('*');
	    var re = //;//当正则需要传参的时候 一定要用全称的写法
	    var re = new RegExp('\\b'+oclass+'\\b');
	    for(var i=0;i<aele.length;i++){
	      if(re.test(aele[i].className)){
		      arr.push(aele[i]);
		    }
	    }
	    return arr;
	  }
    
  匹配敏感词
    var re = /菲称|中国/g;
   //  | 或的意思
   //replace  :第二个参数， 可以是字符串，也可以是一个函数
   
   olnp.onclick = function(){
     at[1].value = at[0].value.replace(re,function(str){
	   //函数的第一个参数 就是匹配成功的字符
	   
	     var result = '';
	     for(var i=0;i<str.length;i++){
	       result += '*';
	     }
	     return result;
	   });
   }
   
   
   /*
   匹配子项  ： 小括号()  (还有另一个意思，分组操作)
   把正则的整体叫做（母亲）
   然后把左边第一个小括号的正则，叫做这个第一子项（母亲的第一个孩子）
   第二个小括号就是第二个孩子
   */
   
   var str1 = '2017-5-4';
   
   var re1 = /\d+-/g;
   str1 = str1.replace(re1,function($0,$1,$2){
   //第一个参数：$0  母亲  第二个参数 $1  第一个孩子 第三个参数 $2 第三个孩子
     //alert($0)
	 return $1 +'.';
	 //return $0.substring(0,$0.length-1)+'.';
   });
   
   //alert(str1);
   
   
   
   /*
     var str = 'abc';
	 var re = /(a)(b)(c)/;
	 alert(str.match(re)); // [abc,a,b,c] 当match不加g的时候才是匹配子项的内容
	 
   */
   
   /*
     替换标签
   */
    var re3 = /<\w+>/g;  //去不了反斜杠
    var re3 = /<[^>]+>/g;
	  var re3 = /<\w\W>+/g;
    
 去掉前后空格
 
    var str = '         hello ';
 
   //alert('('+trim(str)+')');
   //alert('('+str+')');
   function trim(str){
     var re = /^\s+|\s+$/g;
     return str.replace(re,'');
   }

找出最多的字符
  var str = 'agaetedddaytkujrtttttyjytyweewwwwww';
  var arr = str.split('');
  str = arr.sort().join('');
 
  var value = '';
  var index = 0;
 
  var re = /(\w)\1+/g;
 
  str.replace(re,function($0,$1){
    if(index<$0.length){
	  index = $0.length;
	  value = $1;
	}
	
	//alert($1);
  })
  alert('最多的字符：'+value+'重复的次数：'+index)
